// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: unittest.proto

#ifndef PROTOBUF_unittest_2eproto__INCLUDED
#define PROTOBUF_unittest_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3003002 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
// @@protoc_insertion_point(includes)
namespace webrtc {
namespace audioproc {
class OutputData;
class OutputDataDefaultTypeInternal;
extern OutputDataDefaultTypeInternal _OutputData_default_instance_;
class Test;
class TestDefaultTypeInternal;
extern TestDefaultTypeInternal _Test_default_instance_;
class Test_DelayMetrics;
class Test_DelayMetricsDefaultTypeInternal;
extern Test_DelayMetricsDefaultTypeInternal _Test_DelayMetrics_default_instance_;
class Test_EchoMetrics;
class Test_EchoMetricsDefaultTypeInternal;
extern Test_EchoMetricsDefaultTypeInternal _Test_EchoMetrics_default_instance_;
class Test_Frame;
class Test_FrameDefaultTypeInternal;
extern Test_FrameDefaultTypeInternal _Test_Frame_default_instance_;
class Test_Statistic;
class Test_StatisticDefaultTypeInternal;
extern Test_StatisticDefaultTypeInternal _Test_Statistic_default_instance_;
}  // namespace audioproc
}  // namespace webrtc

namespace webrtc {
namespace audioproc {

namespace protobuf_unittest_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_unittest_2eproto

// ===================================================================

class Test_Frame : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:webrtc.audioproc.Test.Frame) */ {
 public:
  Test_Frame();
  virtual ~Test_Frame();

  Test_Frame(const Test_Frame& from);

  inline Test_Frame& operator=(const Test_Frame& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Test_Frame& default_instance();

  static inline const Test_Frame* internal_default_instance() {
    return reinterpret_cast<const Test_Frame*>(
               &_Test_Frame_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  GOOGLE_ATTRIBUTE_NOINLINE void Swap(Test_Frame* other);

  // implements Message ----------------------------------------------

  inline Test_Frame* New() const PROTOBUF_FINAL { return New(NULL); }

  Test_Frame* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Test_Frame& from);
  void MergeFrom(const Test_Frame& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Test_Frame* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:webrtc.audioproc.Test.Frame)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  friend struct protobuf_unittest_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Test_Statistic : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:webrtc.audioproc.Test.Statistic) */ {
 public:
  Test_Statistic();
  virtual ~Test_Statistic();

  Test_Statistic(const Test_Statistic& from);

  inline Test_Statistic& operator=(const Test_Statistic& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Test_Statistic& default_instance();

  static inline const Test_Statistic* internal_default_instance() {
    return reinterpret_cast<const Test_Statistic*>(
               &_Test_Statistic_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  GOOGLE_ATTRIBUTE_NOINLINE void Swap(Test_Statistic* other);

  // implements Message ----------------------------------------------

  inline Test_Statistic* New() const PROTOBUF_FINAL { return New(NULL); }

  Test_Statistic* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Test_Statistic& from);
  void MergeFrom(const Test_Statistic& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Test_Statistic* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 instant = 1;
  bool has_instant() const;
  void clear_instant();
  static const int kInstantFieldNumber = 1;
  ::google::protobuf::int32 instant() const;
  void set_instant(::google::protobuf::int32 value);

  // optional int32 average = 2;
  bool has_average() const;
  void clear_average();
  static const int kAverageFieldNumber = 2;
  ::google::protobuf::int32 average() const;
  void set_average(::google::protobuf::int32 value);

  // optional int32 maximum = 3;
  bool has_maximum() const;
  void clear_maximum();
  static const int kMaximumFieldNumber = 3;
  ::google::protobuf::int32 maximum() const;
  void set_maximum(::google::protobuf::int32 value);

  // optional int32 minimum = 4;
  bool has_minimum() const;
  void clear_minimum();
  static const int kMinimumFieldNumber = 4;
  ::google::protobuf::int32 minimum() const;
  void set_minimum(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:webrtc.audioproc.Test.Statistic)
 private:
  void set_has_instant();
  void clear_has_instant();
  void set_has_average();
  void clear_has_average();
  void set_has_maximum();
  void clear_has_maximum();
  void set_has_minimum();
  void clear_has_minimum();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 instant_;
  ::google::protobuf::int32 average_;
  ::google::protobuf::int32 maximum_;
  ::google::protobuf::int32 minimum_;
  friend struct protobuf_unittest_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Test_EchoMetrics : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:webrtc.audioproc.Test.EchoMetrics) */ {
 public:
  Test_EchoMetrics();
  virtual ~Test_EchoMetrics();

  Test_EchoMetrics(const Test_EchoMetrics& from);

  inline Test_EchoMetrics& operator=(const Test_EchoMetrics& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Test_EchoMetrics& default_instance();

  static inline const Test_EchoMetrics* internal_default_instance() {
    return reinterpret_cast<const Test_EchoMetrics*>(
               &_Test_EchoMetrics_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  GOOGLE_ATTRIBUTE_NOINLINE void Swap(Test_EchoMetrics* other);

  // implements Message ----------------------------------------------

  inline Test_EchoMetrics* New() const PROTOBUF_FINAL { return New(NULL); }

  Test_EchoMetrics* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Test_EchoMetrics& from);
  void MergeFrom(const Test_EchoMetrics& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Test_EchoMetrics* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .webrtc.audioproc.Test.Statistic residual_echo_return_loss = 1;
  bool has_residual_echo_return_loss() const;
  void clear_residual_echo_return_loss();
  static const int kResidualEchoReturnLossFieldNumber = 1;
  const ::webrtc::audioproc::Test_Statistic& residual_echo_return_loss() const;
  ::webrtc::audioproc::Test_Statistic* mutable_residual_echo_return_loss();
  ::webrtc::audioproc::Test_Statistic* release_residual_echo_return_loss();
  void set_allocated_residual_echo_return_loss(::webrtc::audioproc::Test_Statistic* residual_echo_return_loss);

  // optional .webrtc.audioproc.Test.Statistic echo_return_loss = 2;
  bool has_echo_return_loss() const;
  void clear_echo_return_loss();
  static const int kEchoReturnLossFieldNumber = 2;
  const ::webrtc::audioproc::Test_Statistic& echo_return_loss() const;
  ::webrtc::audioproc::Test_Statistic* mutable_echo_return_loss();
  ::webrtc::audioproc::Test_Statistic* release_echo_return_loss();
  void set_allocated_echo_return_loss(::webrtc::audioproc::Test_Statistic* echo_return_loss);

  // optional .webrtc.audioproc.Test.Statistic echo_return_loss_enhancement = 3;
  bool has_echo_return_loss_enhancement() const;
  void clear_echo_return_loss_enhancement();
  static const int kEchoReturnLossEnhancementFieldNumber = 3;
  const ::webrtc::audioproc::Test_Statistic& echo_return_loss_enhancement() const;
  ::webrtc::audioproc::Test_Statistic* mutable_echo_return_loss_enhancement();
  ::webrtc::audioproc::Test_Statistic* release_echo_return_loss_enhancement();
  void set_allocated_echo_return_loss_enhancement(::webrtc::audioproc::Test_Statistic* echo_return_loss_enhancement);

  // optional .webrtc.audioproc.Test.Statistic a_nlp = 4;
  bool has_a_nlp() const;
  void clear_a_nlp();
  static const int kANlpFieldNumber = 4;
  const ::webrtc::audioproc::Test_Statistic& a_nlp() const;
  ::webrtc::audioproc::Test_Statistic* mutable_a_nlp();
  ::webrtc::audioproc::Test_Statistic* release_a_nlp();
  void set_allocated_a_nlp(::webrtc::audioproc::Test_Statistic* a_nlp);

  // optional float divergent_filter_fraction = 5;
  bool has_divergent_filter_fraction() const;
  void clear_divergent_filter_fraction();
  static const int kDivergentFilterFractionFieldNumber = 5;
  float divergent_filter_fraction() const;
  void set_divergent_filter_fraction(float value);

  // @@protoc_insertion_point(class_scope:webrtc.audioproc.Test.EchoMetrics)
 private:
  void set_has_residual_echo_return_loss();
  void clear_has_residual_echo_return_loss();
  void set_has_echo_return_loss();
  void clear_has_echo_return_loss();
  void set_has_echo_return_loss_enhancement();
  void clear_has_echo_return_loss_enhancement();
  void set_has_a_nlp();
  void clear_has_a_nlp();
  void set_has_divergent_filter_fraction();
  void clear_has_divergent_filter_fraction();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::webrtc::audioproc::Test_Statistic* residual_echo_return_loss_;
  ::webrtc::audioproc::Test_Statistic* echo_return_loss_;
  ::webrtc::audioproc::Test_Statistic* echo_return_loss_enhancement_;
  ::webrtc::audioproc::Test_Statistic* a_nlp_;
  float divergent_filter_fraction_;
  friend struct protobuf_unittest_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Test_DelayMetrics : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:webrtc.audioproc.Test.DelayMetrics) */ {
 public:
  Test_DelayMetrics();
  virtual ~Test_DelayMetrics();

  Test_DelayMetrics(const Test_DelayMetrics& from);

  inline Test_DelayMetrics& operator=(const Test_DelayMetrics& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Test_DelayMetrics& default_instance();

  static inline const Test_DelayMetrics* internal_default_instance() {
    return reinterpret_cast<const Test_DelayMetrics*>(
               &_Test_DelayMetrics_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  GOOGLE_ATTRIBUTE_NOINLINE void Swap(Test_DelayMetrics* other);

  // implements Message ----------------------------------------------

  inline Test_DelayMetrics* New() const PROTOBUF_FINAL { return New(NULL); }

  Test_DelayMetrics* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Test_DelayMetrics& from);
  void MergeFrom(const Test_DelayMetrics& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Test_DelayMetrics* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 median = 1;
  bool has_median() const;
  void clear_median();
  static const int kMedianFieldNumber = 1;
  ::google::protobuf::int32 median() const;
  void set_median(::google::protobuf::int32 value);

  // optional int32 std = 2;
  bool has_std() const;
  void clear_std();
  static const int kStdFieldNumber = 2;
  ::google::protobuf::int32 std() const;
  void set_std(::google::protobuf::int32 value);

  // optional float fraction_poor_delays = 3;
  bool has_fraction_poor_delays() const;
  void clear_fraction_poor_delays();
  static const int kFractionPoorDelaysFieldNumber = 3;
  float fraction_poor_delays() const;
  void set_fraction_poor_delays(float value);

  // @@protoc_insertion_point(class_scope:webrtc.audioproc.Test.DelayMetrics)
 private:
  void set_has_median();
  void clear_has_median();
  void set_has_std();
  void clear_has_std();
  void set_has_fraction_poor_delays();
  void clear_has_fraction_poor_delays();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 median_;
  ::google::protobuf::int32 std_;
  float fraction_poor_delays_;
  friend struct protobuf_unittest_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Test : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:webrtc.audioproc.Test) */ {
 public:
  Test();
  virtual ~Test();

  Test(const Test& from);

  inline Test& operator=(const Test& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Test& default_instance();

  static inline const Test* internal_default_instance() {
    return reinterpret_cast<const Test*>(
               &_Test_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  GOOGLE_ATTRIBUTE_NOINLINE void Swap(Test* other);

  // implements Message ----------------------------------------------

  inline Test* New() const PROTOBUF_FINAL { return New(NULL); }

  Test* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Test& from);
  void MergeFrom(const Test& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Test* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Test_Frame Frame;
  typedef Test_Statistic Statistic;
  typedef Test_EchoMetrics EchoMetrics;
  typedef Test_DelayMetrics DelayMetrics;

  // accessors -------------------------------------------------------

  // repeated .webrtc.audioproc.Test.Frame frame = 5;
  int frame_size() const;
  void clear_frame();
  static const int kFrameFieldNumber = 5;
  const ::webrtc::audioproc::Test_Frame& frame(int index) const;
  ::webrtc::audioproc::Test_Frame* mutable_frame(int index);
  ::webrtc::audioproc::Test_Frame* add_frame();
  ::google::protobuf::RepeatedPtrField< ::webrtc::audioproc::Test_Frame >*
      mutable_frame();
  const ::google::protobuf::RepeatedPtrField< ::webrtc::audioproc::Test_Frame >&
      frame() const;

  // repeated .webrtc.audioproc.Test.EchoMetrics echo_metrics = 11;
  int echo_metrics_size() const;
  void clear_echo_metrics();
  static const int kEchoMetricsFieldNumber = 11;
  const ::webrtc::audioproc::Test_EchoMetrics& echo_metrics(int index) const;
  ::webrtc::audioproc::Test_EchoMetrics* mutable_echo_metrics(int index);
  ::webrtc::audioproc::Test_EchoMetrics* add_echo_metrics();
  ::google::protobuf::RepeatedPtrField< ::webrtc::audioproc::Test_EchoMetrics >*
      mutable_echo_metrics();
  const ::google::protobuf::RepeatedPtrField< ::webrtc::audioproc::Test_EchoMetrics >&
      echo_metrics() const;

  // repeated .webrtc.audioproc.Test.DelayMetrics delay_metrics = 12;
  int delay_metrics_size() const;
  void clear_delay_metrics();
  static const int kDelayMetricsFieldNumber = 12;
  const ::webrtc::audioproc::Test_DelayMetrics& delay_metrics(int index) const;
  ::webrtc::audioproc::Test_DelayMetrics* mutable_delay_metrics(int index);
  ::webrtc::audioproc::Test_DelayMetrics* add_delay_metrics();
  ::google::protobuf::RepeatedPtrField< ::webrtc::audioproc::Test_DelayMetrics >*
      mutable_delay_metrics();
  const ::google::protobuf::RepeatedPtrField< ::webrtc::audioproc::Test_DelayMetrics >&
      delay_metrics() const;

  // repeated int32 rms_level = 13;
  int rms_level_size() const;
  void clear_rms_level();
  static const int kRmsLevelFieldNumber = 13;
  ::google::protobuf::int32 rms_level(int index) const;
  void set_rms_level(int index, ::google::protobuf::int32 value);
  void add_rms_level(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      rms_level() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_rms_level();

  // optional int32 num_reverse_channels = 1;
  bool has_num_reverse_channels() const;
  void clear_num_reverse_channels();
  static const int kNumReverseChannelsFieldNumber = 1;
  ::google::protobuf::int32 num_reverse_channels() const;
  void set_num_reverse_channels(::google::protobuf::int32 value);

  // optional int32 num_input_channels = 2;
  bool has_num_input_channels() const;
  void clear_num_input_channels();
  static const int kNumInputChannelsFieldNumber = 2;
  ::google::protobuf::int32 num_input_channels() const;
  void set_num_input_channels(::google::protobuf::int32 value);

  // optional int32 num_output_channels = 3;
  bool has_num_output_channels() const;
  void clear_num_output_channels();
  static const int kNumOutputChannelsFieldNumber = 3;
  ::google::protobuf::int32 num_output_channels() const;
  void set_num_output_channels(::google::protobuf::int32 value);

  // optional int32 sample_rate = 4;
  bool has_sample_rate() const;
  void clear_sample_rate();
  static const int kSampleRateFieldNumber = 4;
  ::google::protobuf::int32 sample_rate() const;
  void set_sample_rate(::google::protobuf::int32 value);

  // optional int32 analog_level_average = 6;
  bool has_analog_level_average() const;
  void clear_analog_level_average();
  static const int kAnalogLevelAverageFieldNumber = 6;
  ::google::protobuf::int32 analog_level_average() const;
  void set_analog_level_average(::google::protobuf::int32 value);

  // optional int32 max_output_average = 7;
  bool has_max_output_average() const;
  void clear_max_output_average();
  static const int kMaxOutputAverageFieldNumber = 7;
  ::google::protobuf::int32 max_output_average() const;
  void set_max_output_average(::google::protobuf::int32 value);

  // optional int32 has_echo_count = 8;
  bool has_has_echo_count() const;
  void clear_has_echo_count();
  static const int kHasEchoCountFieldNumber = 8;
  ::google::protobuf::int32 has_echo_count() const;
  void set_has_echo_count(::google::protobuf::int32 value);

  // optional int32 has_voice_count = 9;
  bool has_has_voice_count() const;
  void clear_has_voice_count();
  static const int kHasVoiceCountFieldNumber = 9;
  ::google::protobuf::int32 has_voice_count() const;
  void set_has_voice_count(::google::protobuf::int32 value);

  // optional int32 is_saturated_count = 10;
  bool has_is_saturated_count() const;
  void clear_is_saturated_count();
  static const int kIsSaturatedCountFieldNumber = 10;
  ::google::protobuf::int32 is_saturated_count() const;
  void set_is_saturated_count(::google::protobuf::int32 value);

  // optional float ns_speech_probability_average = 14;
  bool has_ns_speech_probability_average() const;
  void clear_ns_speech_probability_average();
  static const int kNsSpeechProbabilityAverageFieldNumber = 14;
  float ns_speech_probability_average() const;
  void set_ns_speech_probability_average(float value);

  // optional bool use_aec_extended_filter = 15;
  bool has_use_aec_extended_filter() const;
  void clear_use_aec_extended_filter();
  static const int kUseAecExtendedFilterFieldNumber = 15;
  bool use_aec_extended_filter() const;
  void set_use_aec_extended_filter(bool value);

  // @@protoc_insertion_point(class_scope:webrtc.audioproc.Test)
 private:
  void set_has_num_reverse_channels();
  void clear_has_num_reverse_channels();
  void set_has_num_input_channels();
  void clear_has_num_input_channels();
  void set_has_num_output_channels();
  void clear_has_num_output_channels();
  void set_has_sample_rate();
  void clear_has_sample_rate();
  void set_has_analog_level_average();
  void clear_has_analog_level_average();
  void set_has_max_output_average();
  void clear_has_max_output_average();
  void set_has_has_echo_count();
  void clear_has_has_echo_count();
  void set_has_has_voice_count();
  void clear_has_has_voice_count();
  void set_has_is_saturated_count();
  void clear_has_is_saturated_count();
  void set_has_ns_speech_probability_average();
  void clear_has_ns_speech_probability_average();
  void set_has_use_aec_extended_filter();
  void clear_has_use_aec_extended_filter();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::webrtc::audioproc::Test_Frame > frame_;
  ::google::protobuf::RepeatedPtrField< ::webrtc::audioproc::Test_EchoMetrics > echo_metrics_;
  ::google::protobuf::RepeatedPtrField< ::webrtc::audioproc::Test_DelayMetrics > delay_metrics_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > rms_level_;
  ::google::protobuf::int32 num_reverse_channels_;
  ::google::protobuf::int32 num_input_channels_;
  ::google::protobuf::int32 num_output_channels_;
  ::google::protobuf::int32 sample_rate_;
  ::google::protobuf::int32 analog_level_average_;
  ::google::protobuf::int32 max_output_average_;
  ::google::protobuf::int32 has_echo_count_;
  ::google::protobuf::int32 has_voice_count_;
  ::google::protobuf::int32 is_saturated_count_;
  float ns_speech_probability_average_;
  bool use_aec_extended_filter_;
  friend struct protobuf_unittest_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OutputData : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:webrtc.audioproc.OutputData) */ {
 public:
  OutputData();
  virtual ~OutputData();

  OutputData(const OutputData& from);

  inline OutputData& operator=(const OutputData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const OutputData& default_instance();

  static inline const OutputData* internal_default_instance() {
    return reinterpret_cast<const OutputData*>(
               &_OutputData_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  GOOGLE_ATTRIBUTE_NOINLINE void Swap(OutputData* other);

  // implements Message ----------------------------------------------

  inline OutputData* New() const PROTOBUF_FINAL { return New(NULL); }

  OutputData* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const OutputData& from);
  void MergeFrom(const OutputData& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(OutputData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .webrtc.audioproc.Test test = 1;
  int test_size() const;
  void clear_test();
  static const int kTestFieldNumber = 1;
  const ::webrtc::audioproc::Test& test(int index) const;
  ::webrtc::audioproc::Test* mutable_test(int index);
  ::webrtc::audioproc::Test* add_test();
  ::google::protobuf::RepeatedPtrField< ::webrtc::audioproc::Test >*
      mutable_test();
  const ::google::protobuf::RepeatedPtrField< ::webrtc::audioproc::Test >&
      test() const;

  // @@protoc_insertion_point(class_scope:webrtc.audioproc.OutputData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::webrtc::audioproc::Test > test_;
  friend struct protobuf_unittest_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Test_Frame

// -------------------------------------------------------------------

// Test_Statistic

// optional int32 instant = 1;
inline bool Test_Statistic::has_instant() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Test_Statistic::set_has_instant() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Test_Statistic::clear_has_instant() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Test_Statistic::clear_instant() {
  instant_ = 0;
  clear_has_instant();
}
inline ::google::protobuf::int32 Test_Statistic::instant() const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.Statistic.instant)
  return instant_;
}
inline void Test_Statistic::set_instant(::google::protobuf::int32 value) {
  set_has_instant();
  instant_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audioproc.Test.Statistic.instant)
}

// optional int32 average = 2;
inline bool Test_Statistic::has_average() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Test_Statistic::set_has_average() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Test_Statistic::clear_has_average() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Test_Statistic::clear_average() {
  average_ = 0;
  clear_has_average();
}
inline ::google::protobuf::int32 Test_Statistic::average() const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.Statistic.average)
  return average_;
}
inline void Test_Statistic::set_average(::google::protobuf::int32 value) {
  set_has_average();
  average_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audioproc.Test.Statistic.average)
}

// optional int32 maximum = 3;
inline bool Test_Statistic::has_maximum() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Test_Statistic::set_has_maximum() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Test_Statistic::clear_has_maximum() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Test_Statistic::clear_maximum() {
  maximum_ = 0;
  clear_has_maximum();
}
inline ::google::protobuf::int32 Test_Statistic::maximum() const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.Statistic.maximum)
  return maximum_;
}
inline void Test_Statistic::set_maximum(::google::protobuf::int32 value) {
  set_has_maximum();
  maximum_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audioproc.Test.Statistic.maximum)
}

// optional int32 minimum = 4;
inline bool Test_Statistic::has_minimum() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Test_Statistic::set_has_minimum() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Test_Statistic::clear_has_minimum() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Test_Statistic::clear_minimum() {
  minimum_ = 0;
  clear_has_minimum();
}
inline ::google::protobuf::int32 Test_Statistic::minimum() const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.Statistic.minimum)
  return minimum_;
}
inline void Test_Statistic::set_minimum(::google::protobuf::int32 value) {
  set_has_minimum();
  minimum_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audioproc.Test.Statistic.minimum)
}

// -------------------------------------------------------------------

// Test_EchoMetrics

// optional .webrtc.audioproc.Test.Statistic residual_echo_return_loss = 1;
inline bool Test_EchoMetrics::has_residual_echo_return_loss() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Test_EchoMetrics::set_has_residual_echo_return_loss() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Test_EchoMetrics::clear_has_residual_echo_return_loss() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Test_EchoMetrics::clear_residual_echo_return_loss() {
  if (residual_echo_return_loss_ != NULL) residual_echo_return_loss_->::webrtc::audioproc::Test_Statistic::Clear();
  clear_has_residual_echo_return_loss();
}
inline const ::webrtc::audioproc::Test_Statistic& Test_EchoMetrics::residual_echo_return_loss() const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.EchoMetrics.residual_echo_return_loss)
  return residual_echo_return_loss_ != NULL ? *residual_echo_return_loss_
                         : *::webrtc::audioproc::Test_Statistic::internal_default_instance();
}
inline ::webrtc::audioproc::Test_Statistic* Test_EchoMetrics::mutable_residual_echo_return_loss() {
  set_has_residual_echo_return_loss();
  if (residual_echo_return_loss_ == NULL) {
    residual_echo_return_loss_ = new ::webrtc::audioproc::Test_Statistic;
  }
  // @@protoc_insertion_point(field_mutable:webrtc.audioproc.Test.EchoMetrics.residual_echo_return_loss)
  return residual_echo_return_loss_;
}
inline ::webrtc::audioproc::Test_Statistic* Test_EchoMetrics::release_residual_echo_return_loss() {
  // @@protoc_insertion_point(field_release:webrtc.audioproc.Test.EchoMetrics.residual_echo_return_loss)
  clear_has_residual_echo_return_loss();
  ::webrtc::audioproc::Test_Statistic* temp = residual_echo_return_loss_;
  residual_echo_return_loss_ = NULL;
  return temp;
}
inline void Test_EchoMetrics::set_allocated_residual_echo_return_loss(::webrtc::audioproc::Test_Statistic* residual_echo_return_loss) {
  delete residual_echo_return_loss_;
  residual_echo_return_loss_ = residual_echo_return_loss;
  if (residual_echo_return_loss) {
    set_has_residual_echo_return_loss();
  } else {
    clear_has_residual_echo_return_loss();
  }
  // @@protoc_insertion_point(field_set_allocated:webrtc.audioproc.Test.EchoMetrics.residual_echo_return_loss)
}

// optional .webrtc.audioproc.Test.Statistic echo_return_loss = 2;
inline bool Test_EchoMetrics::has_echo_return_loss() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Test_EchoMetrics::set_has_echo_return_loss() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Test_EchoMetrics::clear_has_echo_return_loss() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Test_EchoMetrics::clear_echo_return_loss() {
  if (echo_return_loss_ != NULL) echo_return_loss_->::webrtc::audioproc::Test_Statistic::Clear();
  clear_has_echo_return_loss();
}
inline const ::webrtc::audioproc::Test_Statistic& Test_EchoMetrics::echo_return_loss() const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.EchoMetrics.echo_return_loss)
  return echo_return_loss_ != NULL ? *echo_return_loss_
                         : *::webrtc::audioproc::Test_Statistic::internal_default_instance();
}
inline ::webrtc::audioproc::Test_Statistic* Test_EchoMetrics::mutable_echo_return_loss() {
  set_has_echo_return_loss();
  if (echo_return_loss_ == NULL) {
    echo_return_loss_ = new ::webrtc::audioproc::Test_Statistic;
  }
  // @@protoc_insertion_point(field_mutable:webrtc.audioproc.Test.EchoMetrics.echo_return_loss)
  return echo_return_loss_;
}
inline ::webrtc::audioproc::Test_Statistic* Test_EchoMetrics::release_echo_return_loss() {
  // @@protoc_insertion_point(field_release:webrtc.audioproc.Test.EchoMetrics.echo_return_loss)
  clear_has_echo_return_loss();
  ::webrtc::audioproc::Test_Statistic* temp = echo_return_loss_;
  echo_return_loss_ = NULL;
  return temp;
}
inline void Test_EchoMetrics::set_allocated_echo_return_loss(::webrtc::audioproc::Test_Statistic* echo_return_loss) {
  delete echo_return_loss_;
  echo_return_loss_ = echo_return_loss;
  if (echo_return_loss) {
    set_has_echo_return_loss();
  } else {
    clear_has_echo_return_loss();
  }
  // @@protoc_insertion_point(field_set_allocated:webrtc.audioproc.Test.EchoMetrics.echo_return_loss)
}

// optional .webrtc.audioproc.Test.Statistic echo_return_loss_enhancement = 3;
inline bool Test_EchoMetrics::has_echo_return_loss_enhancement() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Test_EchoMetrics::set_has_echo_return_loss_enhancement() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Test_EchoMetrics::clear_has_echo_return_loss_enhancement() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Test_EchoMetrics::clear_echo_return_loss_enhancement() {
  if (echo_return_loss_enhancement_ != NULL) echo_return_loss_enhancement_->::webrtc::audioproc::Test_Statistic::Clear();
  clear_has_echo_return_loss_enhancement();
}
inline const ::webrtc::audioproc::Test_Statistic& Test_EchoMetrics::echo_return_loss_enhancement() const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.EchoMetrics.echo_return_loss_enhancement)
  return echo_return_loss_enhancement_ != NULL ? *echo_return_loss_enhancement_
                         : *::webrtc::audioproc::Test_Statistic::internal_default_instance();
}
inline ::webrtc::audioproc::Test_Statistic* Test_EchoMetrics::mutable_echo_return_loss_enhancement() {
  set_has_echo_return_loss_enhancement();
  if (echo_return_loss_enhancement_ == NULL) {
    echo_return_loss_enhancement_ = new ::webrtc::audioproc::Test_Statistic;
  }
  // @@protoc_insertion_point(field_mutable:webrtc.audioproc.Test.EchoMetrics.echo_return_loss_enhancement)
  return echo_return_loss_enhancement_;
}
inline ::webrtc::audioproc::Test_Statistic* Test_EchoMetrics::release_echo_return_loss_enhancement() {
  // @@protoc_insertion_point(field_release:webrtc.audioproc.Test.EchoMetrics.echo_return_loss_enhancement)
  clear_has_echo_return_loss_enhancement();
  ::webrtc::audioproc::Test_Statistic* temp = echo_return_loss_enhancement_;
  echo_return_loss_enhancement_ = NULL;
  return temp;
}
inline void Test_EchoMetrics::set_allocated_echo_return_loss_enhancement(::webrtc::audioproc::Test_Statistic* echo_return_loss_enhancement) {
  delete echo_return_loss_enhancement_;
  echo_return_loss_enhancement_ = echo_return_loss_enhancement;
  if (echo_return_loss_enhancement) {
    set_has_echo_return_loss_enhancement();
  } else {
    clear_has_echo_return_loss_enhancement();
  }
  // @@protoc_insertion_point(field_set_allocated:webrtc.audioproc.Test.EchoMetrics.echo_return_loss_enhancement)
}

// optional .webrtc.audioproc.Test.Statistic a_nlp = 4;
inline bool Test_EchoMetrics::has_a_nlp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Test_EchoMetrics::set_has_a_nlp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Test_EchoMetrics::clear_has_a_nlp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Test_EchoMetrics::clear_a_nlp() {
  if (a_nlp_ != NULL) a_nlp_->::webrtc::audioproc::Test_Statistic::Clear();
  clear_has_a_nlp();
}
inline const ::webrtc::audioproc::Test_Statistic& Test_EchoMetrics::a_nlp() const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.EchoMetrics.a_nlp)
  return a_nlp_ != NULL ? *a_nlp_
                         : *::webrtc::audioproc::Test_Statistic::internal_default_instance();
}
inline ::webrtc::audioproc::Test_Statistic* Test_EchoMetrics::mutable_a_nlp() {
  set_has_a_nlp();
  if (a_nlp_ == NULL) {
    a_nlp_ = new ::webrtc::audioproc::Test_Statistic;
  }
  // @@protoc_insertion_point(field_mutable:webrtc.audioproc.Test.EchoMetrics.a_nlp)
  return a_nlp_;
}
inline ::webrtc::audioproc::Test_Statistic* Test_EchoMetrics::release_a_nlp() {
  // @@protoc_insertion_point(field_release:webrtc.audioproc.Test.EchoMetrics.a_nlp)
  clear_has_a_nlp();
  ::webrtc::audioproc::Test_Statistic* temp = a_nlp_;
  a_nlp_ = NULL;
  return temp;
}
inline void Test_EchoMetrics::set_allocated_a_nlp(::webrtc::audioproc::Test_Statistic* a_nlp) {
  delete a_nlp_;
  a_nlp_ = a_nlp;
  if (a_nlp) {
    set_has_a_nlp();
  } else {
    clear_has_a_nlp();
  }
  // @@protoc_insertion_point(field_set_allocated:webrtc.audioproc.Test.EchoMetrics.a_nlp)
}

// optional float divergent_filter_fraction = 5;
inline bool Test_EchoMetrics::has_divergent_filter_fraction() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Test_EchoMetrics::set_has_divergent_filter_fraction() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Test_EchoMetrics::clear_has_divergent_filter_fraction() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Test_EchoMetrics::clear_divergent_filter_fraction() {
  divergent_filter_fraction_ = 0;
  clear_has_divergent_filter_fraction();
}
inline float Test_EchoMetrics::divergent_filter_fraction() const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.EchoMetrics.divergent_filter_fraction)
  return divergent_filter_fraction_;
}
inline void Test_EchoMetrics::set_divergent_filter_fraction(float value) {
  set_has_divergent_filter_fraction();
  divergent_filter_fraction_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audioproc.Test.EchoMetrics.divergent_filter_fraction)
}

// -------------------------------------------------------------------

// Test_DelayMetrics

// optional int32 median = 1;
inline bool Test_DelayMetrics::has_median() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Test_DelayMetrics::set_has_median() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Test_DelayMetrics::clear_has_median() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Test_DelayMetrics::clear_median() {
  median_ = 0;
  clear_has_median();
}
inline ::google::protobuf::int32 Test_DelayMetrics::median() const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.DelayMetrics.median)
  return median_;
}
inline void Test_DelayMetrics::set_median(::google::protobuf::int32 value) {
  set_has_median();
  median_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audioproc.Test.DelayMetrics.median)
}

// optional int32 std = 2;
inline bool Test_DelayMetrics::has_std() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Test_DelayMetrics::set_has_std() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Test_DelayMetrics::clear_has_std() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Test_DelayMetrics::clear_std() {
  std_ = 0;
  clear_has_std();
}
inline ::google::protobuf::int32 Test_DelayMetrics::std() const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.DelayMetrics.std)
  return std_;
}
inline void Test_DelayMetrics::set_std(::google::protobuf::int32 value) {
  set_has_std();
  std_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audioproc.Test.DelayMetrics.std)
}

// optional float fraction_poor_delays = 3;
inline bool Test_DelayMetrics::has_fraction_poor_delays() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Test_DelayMetrics::set_has_fraction_poor_delays() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Test_DelayMetrics::clear_has_fraction_poor_delays() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Test_DelayMetrics::clear_fraction_poor_delays() {
  fraction_poor_delays_ = 0;
  clear_has_fraction_poor_delays();
}
inline float Test_DelayMetrics::fraction_poor_delays() const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.DelayMetrics.fraction_poor_delays)
  return fraction_poor_delays_;
}
inline void Test_DelayMetrics::set_fraction_poor_delays(float value) {
  set_has_fraction_poor_delays();
  fraction_poor_delays_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audioproc.Test.DelayMetrics.fraction_poor_delays)
}

// -------------------------------------------------------------------

// Test

// optional int32 num_reverse_channels = 1;
inline bool Test::has_num_reverse_channels() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Test::set_has_num_reverse_channels() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Test::clear_has_num_reverse_channels() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Test::clear_num_reverse_channels() {
  num_reverse_channels_ = 0;
  clear_has_num_reverse_channels();
}
inline ::google::protobuf::int32 Test::num_reverse_channels() const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.num_reverse_channels)
  return num_reverse_channels_;
}
inline void Test::set_num_reverse_channels(::google::protobuf::int32 value) {
  set_has_num_reverse_channels();
  num_reverse_channels_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audioproc.Test.num_reverse_channels)
}

// optional int32 num_input_channels = 2;
inline bool Test::has_num_input_channels() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Test::set_has_num_input_channels() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Test::clear_has_num_input_channels() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Test::clear_num_input_channels() {
  num_input_channels_ = 0;
  clear_has_num_input_channels();
}
inline ::google::protobuf::int32 Test::num_input_channels() const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.num_input_channels)
  return num_input_channels_;
}
inline void Test::set_num_input_channels(::google::protobuf::int32 value) {
  set_has_num_input_channels();
  num_input_channels_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audioproc.Test.num_input_channels)
}

// optional int32 num_output_channels = 3;
inline bool Test::has_num_output_channels() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Test::set_has_num_output_channels() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Test::clear_has_num_output_channels() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Test::clear_num_output_channels() {
  num_output_channels_ = 0;
  clear_has_num_output_channels();
}
inline ::google::protobuf::int32 Test::num_output_channels() const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.num_output_channels)
  return num_output_channels_;
}
inline void Test::set_num_output_channels(::google::protobuf::int32 value) {
  set_has_num_output_channels();
  num_output_channels_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audioproc.Test.num_output_channels)
}

// optional int32 sample_rate = 4;
inline bool Test::has_sample_rate() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Test::set_has_sample_rate() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Test::clear_has_sample_rate() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Test::clear_sample_rate() {
  sample_rate_ = 0;
  clear_has_sample_rate();
}
inline ::google::protobuf::int32 Test::sample_rate() const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.sample_rate)
  return sample_rate_;
}
inline void Test::set_sample_rate(::google::protobuf::int32 value) {
  set_has_sample_rate();
  sample_rate_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audioproc.Test.sample_rate)
}

// repeated .webrtc.audioproc.Test.Frame frame = 5;
inline int Test::frame_size() const {
  return frame_.size();
}
inline void Test::clear_frame() {
  frame_.Clear();
}
inline const ::webrtc::audioproc::Test_Frame& Test::frame(int index) const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.frame)
  return frame_.Get(index);
}
inline ::webrtc::audioproc::Test_Frame* Test::mutable_frame(int index) {
  // @@protoc_insertion_point(field_mutable:webrtc.audioproc.Test.frame)
  return frame_.Mutable(index);
}
inline ::webrtc::audioproc::Test_Frame* Test::add_frame() {
  // @@protoc_insertion_point(field_add:webrtc.audioproc.Test.frame)
  return frame_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::webrtc::audioproc::Test_Frame >*
Test::mutable_frame() {
  // @@protoc_insertion_point(field_mutable_list:webrtc.audioproc.Test.frame)
  return &frame_;
}
inline const ::google::protobuf::RepeatedPtrField< ::webrtc::audioproc::Test_Frame >&
Test::frame() const {
  // @@protoc_insertion_point(field_list:webrtc.audioproc.Test.frame)
  return frame_;
}

// optional int32 analog_level_average = 6;
inline bool Test::has_analog_level_average() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Test::set_has_analog_level_average() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Test::clear_has_analog_level_average() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Test::clear_analog_level_average() {
  analog_level_average_ = 0;
  clear_has_analog_level_average();
}
inline ::google::protobuf::int32 Test::analog_level_average() const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.analog_level_average)
  return analog_level_average_;
}
inline void Test::set_analog_level_average(::google::protobuf::int32 value) {
  set_has_analog_level_average();
  analog_level_average_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audioproc.Test.analog_level_average)
}

// optional int32 max_output_average = 7;
inline bool Test::has_max_output_average() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Test::set_has_max_output_average() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Test::clear_has_max_output_average() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Test::clear_max_output_average() {
  max_output_average_ = 0;
  clear_has_max_output_average();
}
inline ::google::protobuf::int32 Test::max_output_average() const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.max_output_average)
  return max_output_average_;
}
inline void Test::set_max_output_average(::google::protobuf::int32 value) {
  set_has_max_output_average();
  max_output_average_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audioproc.Test.max_output_average)
}

// optional int32 has_echo_count = 8;
inline bool Test::has_has_echo_count() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Test::set_has_has_echo_count() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Test::clear_has_has_echo_count() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Test::clear_has_echo_count() {
  has_echo_count_ = 0;
  clear_has_has_echo_count();
}
inline ::google::protobuf::int32 Test::has_echo_count() const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.has_echo_count)
  return has_echo_count_;
}
inline void Test::set_has_echo_count(::google::protobuf::int32 value) {
  set_has_has_echo_count();
  has_echo_count_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audioproc.Test.has_echo_count)
}

// optional int32 has_voice_count = 9;
inline bool Test::has_has_voice_count() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Test::set_has_has_voice_count() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Test::clear_has_has_voice_count() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Test::clear_has_voice_count() {
  has_voice_count_ = 0;
  clear_has_has_voice_count();
}
inline ::google::protobuf::int32 Test::has_voice_count() const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.has_voice_count)
  return has_voice_count_;
}
inline void Test::set_has_voice_count(::google::protobuf::int32 value) {
  set_has_has_voice_count();
  has_voice_count_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audioproc.Test.has_voice_count)
}

// optional int32 is_saturated_count = 10;
inline bool Test::has_is_saturated_count() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Test::set_has_is_saturated_count() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Test::clear_has_is_saturated_count() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Test::clear_is_saturated_count() {
  is_saturated_count_ = 0;
  clear_has_is_saturated_count();
}
inline ::google::protobuf::int32 Test::is_saturated_count() const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.is_saturated_count)
  return is_saturated_count_;
}
inline void Test::set_is_saturated_count(::google::protobuf::int32 value) {
  set_has_is_saturated_count();
  is_saturated_count_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audioproc.Test.is_saturated_count)
}

// repeated .webrtc.audioproc.Test.EchoMetrics echo_metrics = 11;
inline int Test::echo_metrics_size() const {
  return echo_metrics_.size();
}
inline void Test::clear_echo_metrics() {
  echo_metrics_.Clear();
}
inline const ::webrtc::audioproc::Test_EchoMetrics& Test::echo_metrics(int index) const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.echo_metrics)
  return echo_metrics_.Get(index);
}
inline ::webrtc::audioproc::Test_EchoMetrics* Test::mutable_echo_metrics(int index) {
  // @@protoc_insertion_point(field_mutable:webrtc.audioproc.Test.echo_metrics)
  return echo_metrics_.Mutable(index);
}
inline ::webrtc::audioproc::Test_EchoMetrics* Test::add_echo_metrics() {
  // @@protoc_insertion_point(field_add:webrtc.audioproc.Test.echo_metrics)
  return echo_metrics_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::webrtc::audioproc::Test_EchoMetrics >*
Test::mutable_echo_metrics() {
  // @@protoc_insertion_point(field_mutable_list:webrtc.audioproc.Test.echo_metrics)
  return &echo_metrics_;
}
inline const ::google::protobuf::RepeatedPtrField< ::webrtc::audioproc::Test_EchoMetrics >&
Test::echo_metrics() const {
  // @@protoc_insertion_point(field_list:webrtc.audioproc.Test.echo_metrics)
  return echo_metrics_;
}

// repeated .webrtc.audioproc.Test.DelayMetrics delay_metrics = 12;
inline int Test::delay_metrics_size() const {
  return delay_metrics_.size();
}
inline void Test::clear_delay_metrics() {
  delay_metrics_.Clear();
}
inline const ::webrtc::audioproc::Test_DelayMetrics& Test::delay_metrics(int index) const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.delay_metrics)
  return delay_metrics_.Get(index);
}
inline ::webrtc::audioproc::Test_DelayMetrics* Test::mutable_delay_metrics(int index) {
  // @@protoc_insertion_point(field_mutable:webrtc.audioproc.Test.delay_metrics)
  return delay_metrics_.Mutable(index);
}
inline ::webrtc::audioproc::Test_DelayMetrics* Test::add_delay_metrics() {
  // @@protoc_insertion_point(field_add:webrtc.audioproc.Test.delay_metrics)
  return delay_metrics_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::webrtc::audioproc::Test_DelayMetrics >*
Test::mutable_delay_metrics() {
  // @@protoc_insertion_point(field_mutable_list:webrtc.audioproc.Test.delay_metrics)
  return &delay_metrics_;
}
inline const ::google::protobuf::RepeatedPtrField< ::webrtc::audioproc::Test_DelayMetrics >&
Test::delay_metrics() const {
  // @@protoc_insertion_point(field_list:webrtc.audioproc.Test.delay_metrics)
  return delay_metrics_;
}

// repeated int32 rms_level = 13;
inline int Test::rms_level_size() const {
  return rms_level_.size();
}
inline void Test::clear_rms_level() {
  rms_level_.Clear();
}
inline ::google::protobuf::int32 Test::rms_level(int index) const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.rms_level)
  return rms_level_.Get(index);
}
inline void Test::set_rms_level(int index, ::google::protobuf::int32 value) {
  rms_level_.Set(index, value);
  // @@protoc_insertion_point(field_set:webrtc.audioproc.Test.rms_level)
}
inline void Test::add_rms_level(::google::protobuf::int32 value) {
  rms_level_.Add(value);
  // @@protoc_insertion_point(field_add:webrtc.audioproc.Test.rms_level)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Test::rms_level() const {
  // @@protoc_insertion_point(field_list:webrtc.audioproc.Test.rms_level)
  return rms_level_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Test::mutable_rms_level() {
  // @@protoc_insertion_point(field_mutable_list:webrtc.audioproc.Test.rms_level)
  return &rms_level_;
}

// optional float ns_speech_probability_average = 14;
inline bool Test::has_ns_speech_probability_average() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Test::set_has_ns_speech_probability_average() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Test::clear_has_ns_speech_probability_average() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Test::clear_ns_speech_probability_average() {
  ns_speech_probability_average_ = 0;
  clear_has_ns_speech_probability_average();
}
inline float Test::ns_speech_probability_average() const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.ns_speech_probability_average)
  return ns_speech_probability_average_;
}
inline void Test::set_ns_speech_probability_average(float value) {
  set_has_ns_speech_probability_average();
  ns_speech_probability_average_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audioproc.Test.ns_speech_probability_average)
}

// optional bool use_aec_extended_filter = 15;
inline bool Test::has_use_aec_extended_filter() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Test::set_has_use_aec_extended_filter() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Test::clear_has_use_aec_extended_filter() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Test::clear_use_aec_extended_filter() {
  use_aec_extended_filter_ = false;
  clear_has_use_aec_extended_filter();
}
inline bool Test::use_aec_extended_filter() const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.use_aec_extended_filter)
  return use_aec_extended_filter_;
}
inline void Test::set_use_aec_extended_filter(bool value) {
  set_has_use_aec_extended_filter();
  use_aec_extended_filter_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audioproc.Test.use_aec_extended_filter)
}

// -------------------------------------------------------------------

// OutputData

// repeated .webrtc.audioproc.Test test = 1;
inline int OutputData::test_size() const {
  return test_.size();
}
inline void OutputData::clear_test() {
  test_.Clear();
}
inline const ::webrtc::audioproc::Test& OutputData::test(int index) const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.OutputData.test)
  return test_.Get(index);
}
inline ::webrtc::audioproc::Test* OutputData::mutable_test(int index) {
  // @@protoc_insertion_point(field_mutable:webrtc.audioproc.OutputData.test)
  return test_.Mutable(index);
}
inline ::webrtc::audioproc::Test* OutputData::add_test() {
  // @@protoc_insertion_point(field_add:webrtc.audioproc.OutputData.test)
  return test_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::webrtc::audioproc::Test >*
OutputData::mutable_test() {
  // @@protoc_insertion_point(field_mutable_list:webrtc.audioproc.OutputData.test)
  return &test_;
}
inline const ::google::protobuf::RepeatedPtrField< ::webrtc::audioproc::Test >&
OutputData::test() const {
  // @@protoc_insertion_point(field_list:webrtc.audioproc.OutputData.test)
  return test_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace audioproc
}  // namespace webrtc

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_unittest_2eproto__INCLUDED
